---
title: "T1: Vehicle Availability"
format: 
  html:
    theme: minty
    toc: true
    toc-location: left
editor: visual
---

## Defining file paths (MODIFY THESE BEFORE RUNNING CODE)

```{r, warning = FALSE, message = FALSE}
library(here)

# File path for where this T1.qmd file is located
T1_folder <- file.path(here("T1"))

# File path for where the inputs folder is located
inputs_folder <- file.path(here("model", "inputs"))

# File path for where the SQL databases are located
sql_db_folder <- file.path(here("T1"))
```

## Load libraries

This analysis uses the following packages:

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(sf)
library(DBI)
library(here)
library(leaflet)
library(maptiles)
library(tidyterra)
library(knitr)
library(tigris)

sf::sf_use_s2(FALSE)
```

## Examine the study area

There is a shapefile defining the traffic analysis zones included in the model in the inputs subfolder of the model directory. You can open this in a GIS software program of your choice to take a look at it.

Here, I'll load it and make a quick static map of the full model area.

And here's an interactive map of just Somerville and Medford.

The model uses TAZs as the basis for (dis)aggregating the populations in Rhode Island and New Hampshire, but uses census blocks within Massachusetts. Here are the census blocks in Somerville and Medford.

## Examine base scenario inputs

Open the file CTPS_TDM23.scenarios at the top level of the model directory. After the line `Scenario "Base"`, you'll see a list of parameters defined. Most of these are the locations of files containing input data. The vehicle availability model is primarily based on population and employment data, and it also uses the ratio of transit accessibility to car accessibility, which is a function of the transit and highway networks.

### Population files

There is one population file for Massachusetts and another for the parts of Rhode Island and New Hampshire that are included in the model area. Let's take a look at them.

```{r}
MA_pop <- file.path(inputs_folder, "zonal",
               "ma_population_run97-176_2019_v20240109.csv") |>
  read_csv(show_col_types = FALSE) |>
  mutate(block_id = as.character(block_id))

head(MA_pop, n = 10) |>
  kable()
```

As you can see, this is person-level data. The record for each person indicates what household they are in, what census block they live in, four household-level variables (number of people, number of workers, and number of children), and three person-level variables (age, income, and whether they are a worker).

Here is the dataset for Rhode Island and New Hampshire. It includes the same variables, but note that the block ID refers to a TAZ rather than a census block.

```{r}
RINH_pop <- file.path(inputs_folder, "zonal",
               "nhri_population_2020_v20230518.csv") |>
  read_csv(show_col_types = FALSE)

head(RINH_pop, n = 10) |>
  kable()
```

### Employment files

Employment data is likewise stored in separate files for the zones within and outside of Massachusetts.

Let's take a look at the employment file for Massachusetts.

```{r}
MA_emp <- file.path(inputs_folder, "zonal",
               "ma_employment_run97-176_2019_v20240109.csv") |>
  read_csv(show_col_types = FALSE) |>
  mutate(block_id = as.character(block_id))

head(MA_emp, n = 10) |>
  kable()
```

This is block-level data. It shows the total number of households in each block, as well as the total number of jobs in each of ten categories:

1.  Construction

2.  Education and health services

3.  Financial activities

4.  Public administration

5.  Information

6.  Retail, leisure, and hospitality

7.  Manufacturing

8.  Other services

9.  Professional and business services

10. Trade, transportation, and utilities

Again, the New Hampshire/Rhode Island file has the same variables, and block IDs refer to TAZs rather than census blocks. For some reason, this file has about 4500 Massachusetts census blocks appended to the beginning, so I'm filtering those out when I load them below.

```{r}
RINH_emp <- file.path(inputs_folder, "zonal",
               "nhri_employment_2020_v20230518.csv") |>
  read_csv(show_col_types = FALSE) |>
  mutate(block_id = as.character(block_id)) |>
  filter(str_length(block_id) < 10)

head(RINH_emp, n = 10) |>
  kable()
```

### Road network

The road network file is listed in the scenarios file as "Highway Input" ("highways" is a term we're using to refer to all roads). To view this file, open it in TransCAD, either by selecting "Open..." from the file menu, or by dragging and dropping it into main TransCAD pane.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "open-hwy.gif") |>
  knitr::include_graphics()
```

In ArcGIS Pro or QGIS, you can view the data associated with a spatial data layer by opening its attribute table. In TransCAD, you do it by creating a new "dataview" while the layer is active. Select New Dataview from the Dataview menu.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "hwy-dataview.gif") |>
  knitr::include_graphics()
```

### Transit network

The transit network is stored in a transit route system (\*.rts) file, which you can likewise open by dragging and dropping into TransCAD.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "open-transit.gif") |>
  knitr::include_graphics()
```

In this case, you'll notice that your map includes a layer of routes as well as a layer of links (also nodes and stops, which are not visible by default). To create a dataview for one of these layers, set it as the active layer before creating a new dataview (which you can do either from the Dataview menu or using the New Dataview button.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "transit-dataview.gif") |>
  knitr::include_graphics()
```

## Edit model inputs

Think about what information is included in the vehicle availability model. If you changed something about population, employment, the highway network, or the transit network, how might that change vehicle availability?

There is a shopping center near assembly row that currently includes a Trader Joe's grocery store, a TJ Maxx, and a few other businesses. What if we replaced that whole development with 300 units of affordable housing, and also closed the adjacent Fellsway bridge over the Mystic River, and also removed all transit routes that cross that bridge? What would be the predicted vehicle ownership in that new housing development, and how would vehicle ownership change in other neighborhoods in the vicinity?

### Change population

The shopping center I'm thinking about replacing with housing is block 250173501031013. I don't think there is any housing there now, but let's check.

```{r}
# Summarize the number of persons in each block ID
summarized_block_pop <- MA_pop |>
  filter(block_id %in% c("250173531021004", "250173531022011", "250173537003005", "250173536005005", "250250001001001")) |>
  group_by(block_id) |>
  summarize(total_people = n())

# Display the summarized data
summarized_block_pop
  
```

It looks like the model does actually include 133 people across 56 households in that block. This is probably because their population data comes from the American Community Survey, which is at the tract level, and they used PopulationSim ([https://activitysim.github.io/populationsim/](PopulationSim)) to disaggregate it to the block level. Or maybe there is some housing in that block that I'm not aware of. At any rate, we'll leave those households here and add an additional 300 households with the following characteristics:

-   Incomes follow a poisson distribution with an average of \$30,000 per year

-   Half of all households are two-person households, one-third are one-person households, and one sixth are three-person households.

-   All households are one-worker households

-   Half of all people who are the second or third person in the household are children

-   The average age of a child is 10. Children's ages are normally distributed with a standard deviation of five years (truncated at zero and 17 years).

-   The average age of an adult is 50. Adults ages are normally distributed with a standard deviation of ten years (truncated at 18 years).

First I'll generate one worker for each household.

```{r}
gen_pop <- function(my_block_id, addit_ppl, new_hh_name) {
  tibble(
    hid = paste0(new_hh_name, seq(1, addit_ppl, by=1)),
    block_id = my_block_id,
    hh_inc = rpois(n = addit_ppl, lambda = 28000),
    persons_seed = runif(n = addit_ppl),
    age = round(rnorm(n = addit_ppl, mean = 45, sd = 15)),
    workers = 1,
    is_worker = 1,
    person_num = 1,
    is_child = FALSE
  ) |>
    mutate(
      persons = case_when(
        persons_seed < 0.5 ~ 2,
        persons_seed < 0.83 ~ 1,
        TRUE ~ 3
      ),
      age = ifelse(age < 18, 18, age),
      wage_inc = hh_inc
    ) |>
    select(-persons_seed)
}

# Example usage
new_pop_11 <- gen_pop("250173531021004",300, "mitfields") #mitfields
new_pop_12 <- gen_pop("250173531022011",400, "mitcore") #mitcore
new_pop_13 <- gen_pop("250173537003005",300, "hvdyard") #hvdyard
new_pop_14 <- gen_pop("250173536005005",300, "hvdsci") #hvdsci
new_pop_15 <- gen_pop("250250001001001",400, "hvdfields") #hvdfields


```

Now, I'll generate a second person for any households that have a second person.

```{r}
add_second_person <- function(new_pop_1) {
  new_pop_2 <- new_pop_1 |>
    filter(persons > 1) |>
    select(hid, block_id, hh_inc, persons, workers) |>
    mutate(
      person_num = 2,
      is_worker = 0,
      wage_inc = 0,
      
      child_seed = runif(n = n()),
      is_child = child_seed < 0.5
    ) |>
    select(-child_seed)

  # Separate children and adults
  new_pop_2_kids <- new_pop_2 |>
    filter(is_child)
  
  new_pop_2_kids <- new_pop_2_kids |>
    mutate(age = round(rnorm(n = nrow(new_pop_2_kids), mean=10, sd=5))) |>
    mutate(age = case_when(age < 0 ~ 0, age > 17 ~ 17, TRUE ~ age))

  new_pop_2_adult <- new_pop_2 |>
    filter(!is_child)
  
  new_pop_2_adult <- new_pop_2_adult |>
    mutate(age = round(rnorm(n = nrow(new_pop_2_adult), mean=50, sd=10))) |>
    mutate(age = ifelse(age < 18, 18, age))

  # Combine both groups
  new_pop_2 <- bind_rows(new_pop_2_adult, new_pop_2_kids)

  return(new_pop_2)
}

# Example usage
new_pop_21 <- add_second_person(new_pop_11)
new_pop_22 <- add_second_person(new_pop_12)
new_pop_23 <- add_second_person(new_pop_13)
new_pop_24 <- add_second_person(new_pop_14)
new_pop_25 <- add_second_person(new_pop_15)
```

And now I'll generate a third person for any household that has one.

```{r}
add_third_person <- function(new_pop_1) {
  new_pop_3 <- new_pop_1 |>
    filter(persons > 2) |>
    select(hid, block_id, hh_inc, persons, workers) |>
    mutate(
      person_num = 3,
      is_worker = 0,
      wage_inc = 0,
      child_seed = runif(n = n()),
      is_child = child_seed < 0.5
    ) |>
    select(-child_seed)

  new_pop_3_kids <- new_pop_3 |>
    filter(is_child)
  
  new_pop_3_kids <- new_pop_3_kids |>
    mutate(age = round(rnorm(n = nrow(new_pop_3_kids), mean=10, sd=5))) |>
    mutate(age = case_when(age < 0 ~ 0, age > 17 ~ 17, TRUE ~ age))

  new_pop_3_adult <- new_pop_3 |>
    filter(!is_child)
  
  new_pop_3_adult <- new_pop_3_adult |>
    mutate(age = round(rnorm(n = nrow(new_pop_3_adult), mean=50, sd=10))) |>
    mutate(age = ifelse(age < 18, 18, age))

  # Combine both groups
  new_pop_3 <- bind_rows(new_pop_3_adult, new_pop_3_kids)

  return(new_pop_3)
}

# Example usage
new_pop_31 <- add_third_person(new_pop_11)
new_pop_32 <- add_third_person(new_pop_12)
new_pop_33 <- add_third_person(new_pop_13)
new_pop_34 <- add_third_person(new_pop_14)
new_pop_35 <- add_third_person(new_pop_15)
```

And now we'll put all those people into one dataframe and count the number of children in each household.

```{r}

combine_population <- function(new_pop_1, new_pop_2, new_pop_3) {
  new_pop <- bind_rows(new_pop_1, new_pop_2, new_pop_3) |>
    group_by(hid) |>
    mutate(children = sum(is_child)) |>
    select(-is_child) |>
    arrange(hid, person_num) |>
    ungroup()

  return(new_pop)
}

# Example usage
new_pop_mitfields <- combine_population(new_pop_11, new_pop_21, new_pop_31)
new_pop_mitcore <- combine_population(new_pop_12, new_pop_22, new_pop_32)
new_pop_hvdyard <- combine_population(new_pop_13, new_pop_23, new_pop_33)
new_pop_hvdsci <- combine_population(new_pop_14, new_pop_24, new_pop_34)
new_pop_hvdfields <- combine_population(new_pop_15, new_pop_25, new_pop_35)

```

And I'll create a new population data frame for Massachusetts that includes these files and write that to a new csv file.

```{r}

# List of new population datasets
new_pops <- list(new_pop_mitfields, new_pop_mitcore, new_pop_hvdyard, new_pop_hvdsci, new_pop_hvdfields)

# Combine all populations
MA_pop_updated <- bind_rows(MA_pop, new_pops)  
MA_pop_updated

# Calculate the total households for each block ID
households_per_block <- MA_pop_updated |> 
  filter(block_id %in% block_ids) |> 
  group_by(block_id) |> 
  summarize(total_households = length(unique(hid)))

# Display the result
households_per_block

# Summarize the number of persons in each block ID

summarized_block_pop <- MA_pop_updated |> filter(block_id %in% c("250173531021004", "250173531022011", "250173537003005", "250173536005005", "250250001001001")) |> group_by(block_id) |> summarize(total_people = n())

# Display the summarized data

summarized_block_pop


```

```{r}
# Write to CSV
write_csv(MA_pop_updated, file.path(inputs_folder, "zonal", "ma_pop_nounis.csv"))

#MA_pop_updated_read <- read.csv(file.path(inputs_folder, "zonal", "ma_pop_nounis.csv"))

# summarized_block_pop <- MA_pop_updated |>
#   filter(block_id %in% c("250173531021004", "250173531022011", "250173537003005", "250173536005005", "250250001001001")) |>
#   group_by(block_id) |>
#   summarize(total_people = n())

# summarized_block_pop

nrow(MA_pop)
nrow(MA_pop_updated)
```

Notice that the way I'm representing the addition of affordable housing is that I'm adding 300 new households to the region. This means I'm assuming that all of these new housing units would be filled by people moving in from outside the region. If I wanted to assume that they were vacating other housing in the region, or that that they were leaving other households to form new households, I'd have to take a different approach here.

### Change employment

Again, the block we're thinking about targeting is block 250173501031013. Let's take a look at the employment file.

```{r}
block_ids <- c("250173531021004", "250173531022011", "250173537003005", "250173536005005", "250250001001001")

MA_emp |>
  filter(block_id %in% block_ids) |>
  t() |>
  kable()
```

You can see that this block has 344 jobs across various sectors, and over three quarters of those are in "Retail and Leisure," which makes sense because this is a shopping center. Since the scenario I'm testing would replace the shopping center with housing, I'm going to remove all those jobs, but leave the households. I'll also increase the number of households by 300, to represent the 300 affordable housing units I'm adding.

```{r}

hh_per_block <- MA_pop_updated |>
  filter(block_id %in% block_ids) |>
  group_by(block_id) |>
  summarize(total_households = length(unique(hid)))

hh_per_block

# Create the new_emp tibble
new_emp <- tibble(block_id = block_ids,
                  `1_constr` = 0,
                  `2_eduhlth` = 0,
                  `3_finance` = 0,
                  `4_public` = 0,
                  `5_info` = 0,
                  `6_ret_leis` = 0,
                  `7_manu` = 0,
                  `8_other` = 0,
                  `9_profbus` = 0,
                  `10_ttu` = 0,
                  total_jobs = 0,
                  total_households = 0)

# Merge the data to get total_households per block_id
new_emp <- left_join(new_emp, hh_per_block, by = "block_id") |>
  select(block_id, `1_constr`, `2_eduhlth`, `3_finance`, `4_public`, `5_info`, `6_ret_leis`, `7_manu`, `8_other`, `9_profbus`, `10_ttu`, total_jobs, total_households = total_households.y)

# Display the updated new_emp tibble
new_emp

MA_emp_updated <- MA_emp |>
  filter(!block_id %in% block_ids) |>
  bind_rows(new_emp)

MA_emp_updated |>
  filter(block_id %in% block_ids) |>
  t() |>
  kable()

write_csv(MA_emp_updated, file.path(inputs_folder, "zonal", "ma_emp_nounis.csv"))


```

### Change highway network

I'm going to delete the Fellsway bridge over the Mystic River.

You'll need to edit the highway network from TransCAD. Start by making a copy of the `inputs/networks/tdw23.1.0/2019` folder and renaming it.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "copy-paste.gif") |>
  knitr::include_graphics()
```

Now open the highway network file from that new directory in TransCAD. You may find it helpful to turn on a basemap to help you orient yourself.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "basemap.gif") |>
  knitr::include_graphics()

```

I'm going to zoom to the Fellsway bridge and delete those links from the network.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "delete-links.gif") |>
  knitr::include_graphics()
```

### Change transit network

There are transit routes that also use that bridge, and those are still represented in the transit network. If we ran the model like this, we would effectively saying that the bridge is still there (it serves buses) but that it's closed to non-transit vehicles. But I want to look at a scenario where the bridge is gone, and the transit agency has responded by just removing those entire routes from its network.

Open the transit routes file in TransCAD (the one in the folder that you copied - don't edit your original file). When you open it, you'll see a message that says the underlying highway network has changed and asking if you want to update the transit network to match. Select yes. You'll notice that when you zoom in on the Fellsway bridge now, there's a gap in the transit routes that go over the bridge. The model still has service connecting the stops on that routes that go over the bridge though.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "transit-open-edit.gif") |>
  knitr::include_graphics()
```

We're going to go ahead and delete the transit routes that were using the bridge we deleted.

```{r, echo=FALSE, eval = FALSE}

here("T1",
     "gifs",
     "delete-transit.gif") |>
  knitr::include_graphics()
```

## Create scenarios

In the file `CTPS_TDM23.scenarios`, you can copy the lines from `Scenario "Base"` to `EndScenario` (inclusive) and paste them below the base scenario. Then for any files you've created alternative versions of, update the file paths to refer to the modified files. Save the modified scenario file.

## Run the vehicle model for each scenario

Open the model file in TransCAD.

Select the scenario you want to run (the options should be "Base" and the other scenario that you've modified in the `*.scenarios` file).

Right-click on the box for "Vehicle Availability" and select Run -\> Run Model to Here.

Then go get lunch or something. On my computer, this part of the model run takes about 30 minutes Most of that time is the initialization step(s).

Do this for both the base scenario and the alternative scenario you've created.

```{r, eval = FALSE}

here("T1",
     "gifs",
     "start-run.gif") |>
  knitr::include_graphics()
```

## Compare scenario results

The output of the vehicle availability submodel will be stored in a file called tdm23.db in the output directory for your scenario. This is an SQLite database and you can use the `RSQLite` package to interact with it.

Let's start by loading the results of for the existing condition.

```{r, message = FALSE, warning = FALSE, echo = FALSE, results = "hide"}
# Creating a shp file for our target blocks

# Download census block data for MA
ma_blocks <- blocks(state = "MA", year = 2010, class = "sf")

# Target blocks
target_blocks <- c("250173531021004", "250173531022011", "250173537003005", "250173536005005", "250250001001001")

# Filter MA census blocks for our target blocks
target_blocks_sf <- ma_blocks |> filter(GEOID10 %in% target_blocks)

# Save as a shapefile
st_write(target_blocks_sf, file.path(T1_folder, "target_blocks.shp"), append = FALSE)
```

```{r}
# Connect to SQLite db for base scenario
base_db <- dbConnect(drv=RSQLite::SQLite(), 
                     dbname=file.path(sql_db_folder, "tdm23_base.db"))


```

Now we can see a list of the tables that are available in that database.

```{r}
dbListTables(base_db)
```

Let's take a look at the vehicles (veh) table.

```{r}
target_blocks <- c("250173531021004", "250173531022011", "250173537003005", "250173536005005", "250250001001001")

# Extract vehicle availability data from the base scenario
my_query <- paste0("SELECT * FROM veh WHERE block_id IN ('", 
                   paste(target_blocks, collapse = "', '"), "')")

target_vehs_base <- dbGetQuery(base_db, my_query)

```

This table shows whether each household has zero vehicles (zv), insufficient vehicles (iv), or sufficient vehicles (sv). It also shows the predicted number of vehicles. Since the vehicle availability model only predicts the vehicle availability category, I'm not sure where the predicted number of vehicles is coming from. We won't use it.

The changes we made for our alternative scenario would have the greatest effect on vehicle availability for households within Somerville and Medford. So let's take a look at just those.

Now we can close the connection to the baseline scenario and take a look at the results of the alternative scenario.

```{r}
dbDisconnect(base_db)

alt_db <- dbConnect(drv=RSQLite::SQLite(), 
                     dbname=file.path(sql_db_folder, "tdm23_alt_FINAL.db"))

```

Now let's look at vehicle availability in Somerville and Medford under the alternative scenario.

```{r, warning=FALSE, message=FALSE}
# Query vehicle availability data for the alternative scenario
my_query_alt <- paste0("SELECT * FROM veh WHERE block_id IN ('", 
                        paste(target_blocks, collapse = "', '"), "')")

target_vehs_alt <- dbGetQuery(alt_db, my_query_alt)

# Close connection to the alternative scenario database
dbDisconnect(alt_db)

# Display sample data
head(target_vehs_alt) |> kable()
```

Now we can combine those into a single dataframe and make some comparisons.

```{r, message = FALSE, warning = FALSE}
# Clean up base and alternative scenario data
target_vehs_base <- target_vehs_base |> 
  rename(veh_suff_base = veh_suff) |> 
  select(-num_vehs)

target_vehs_alt <- target_vehs_alt |> 
  rename(veh_suff_alt = veh_suff) |> 
  select(-num_vehs)

# Merge datasets, ensuring missing values are handled 
target_vehs_dif <- full_join(target_vehs_base, target_vehs_alt) |>
  mutate(veh_suff_base = ifelse(is.na(veh_suff_base), "new", veh_suff_base))

# Categorize vehicle ownership changes
target_vehs_changed_hh <- target_vehs_dif |>  
  mutate(change = case_when(
    veh_suff_base == "new" & veh_suff_alt == "zv" ~ "New zv",
    veh_suff_base == "new" & veh_suff_alt == "iv" ~ "New iv",
    veh_suff_base == "new" & veh_suff_alt == "sv" ~ "New sv",
    veh_suff_base == "zv" & veh_suff_alt == "iv" ~ "Gained vehicle",
    veh_suff_base == "zv" & veh_suff_alt == "sv" ~ "Gained vehicle",
    veh_suff_base == "sv" & veh_suff_alt == "zv" ~ "Lost vehicle",
    veh_suff_base == "sv" & veh_suff_alt == "iv" ~ "Lost vehicle",
    veh_suff_base == "iv" & veh_suff_alt == "zv" ~ "Lost vehicle",
    veh_suff_base == "iv" & veh_suff_alt == "sv" ~ "Gained vehicle",
    TRUE ~ "No change"
  ))

# Summarize changes at the block level
target_vehs_changed_blocks <- target_vehs_changed_hh |> mutate(block_id = as.character(block_id)) |> 
  group_by(block_id) |>  
  summarise(
    n_hhs = n(),  # Count number of households per block
    n_new_zv = sum(change == "New zv", na.rm = TRUE),
    n_new_iv = sum(change == "New iv", na.rm = TRUE),
    n_new_sv = sum(change == "New sv", na.rm = TRUE),
    n_gained_veh = sum(change == "Gained vehicle", na.rm = TRUE),
    n_lost_veh = sum(change == "Lost vehicle", na.rm = TRUE)
  ) |>
  rename(GEOID10 = block_id) 

# Display summary table
kable(target_vehs_changed_blocks)
```

You can see that there are twelve census blocks with any changes to household vehicle ownership. Let's take a look at them on a map.

```{r, warning=FALSE, message=FALSE}
# Load spatial data for the region
target_blocks_sf <- st_read(file.path(T1_folder, "target_blocks.shp"))

# Transform CRS to WGS84 for Leaflet compatibility
target_blocks_sf <- st_transform(target_blocks_sf, crs = 4326)

# Ensure only polygons/multipolygons are included
target_blocks_sf <- st_collection_extract(target_blocks_sf, "POLYGON")
target_blocks_sf <- target_blocks_sf[st_geometry_type(target_blocks_sf) %in% c("POLYGON", "MULTIPOLYGON"), ]
target_blocks_sf <- target_blocks_sf[!st_is_empty(target_blocks_sf), ]

# Merge spatial and vehicle ownership data
dif_blocks <- target_blocks_sf |>  
  left_join(target_vehs_changed_blocks, by = "GEOID10")  

# Restore `sf` properties if lost
dif_blocks <- st_as_sf(dif_blocks)

# Ensure only valid geometries remain
dif_blocks <- dif_blocks[st_geometry_type(dif_blocks) %in% c("POLYGON", "MULTIPOLYGON"), ]
dif_blocks <- dif_blocks[!st_is_empty(dif_blocks), ]

# Create labels for the map
veh_labels <- paste0(
  dif_blocks$n_hhs, " total households<br/>",
  dif_blocks$n_new_zv, " new car-free households<br/>",
  dif_blocks$n_new_iv, " new car-lite households<br/>",
  dif_blocks$n_new_sv, " new full-car households<br/>",
  dif_blocks$n_lost_veh, " households lost a vehicle<br/>",
  dif_blocks$n_gained_veh, " households gained a vehicle"
) |> lapply(htmltools::HTML)

# Generate interactive map
leaflet(dif_blocks) |>  
  addProviderTiles(provider = "CartoDB.Positron") |>  
  addPolygons(
    weight = 2,
    color = "forestgreen",
    fillColor = "forestgreen",
    fillOpacity = 0.1,
    highlightOptions = highlightOptions(weight = 3, fillOpacity = 0.5),
    label = veh_labels
  )

```

You might decide to do your data visualization in ArcGIS or QGIS. If that's you preference, you can write the spatial data to a shapefile:

```{r, warning=FALSE, message=FALSE, eval = FALSE}

# Optionally export spatial data for use in GIS software
st_write(dif_blocks, file.path(T1_folder, "dif_blocks.shp"), append = FALSE)
```
